"""
    lbfcs/__main__.py
    ~~~~~~~~~~~~~~~~

    lbFCS command line interface

    :authors: Florian Stehr 2019
"""

import os
import sys
import argparse
import numpy as np
import pandas as pd
import time
import warnings
warnings.filterwarnings("ignore")

import picasso.io
import picasso.postprocess as postprocess
import picasso.render as render

import lbfcs.picasso_wrap as pic_wrap
import lbfcs.pickprops as props
import lbfcs.pickprops_calls as props_call
import lbfcs.io

#%%
def _logo():
    '''
    Prints 'lbFCS logo'
    '''
    print('       __       __')
    print('      / /      / /')
    print('     / /      / /')
    print('    / /      / /_____  ______ _____ ____')
    print('   / /      / __    / /      /     /')
    print('  / /      / /   / / /____  /     /___ ')
    print(' / /____  / /___/ / /      /         /')
    print('/______/ /_______/ /      /_________/')
    print('')
    print('--------------------------------------')
    print('--------------------------------------')
    
#%%
def _lbfcs(path,
           box=5,
           mng=400,
           segments=500,
           oversampling=5,
           box_pick=9,
           mng_pick=400,
           pick_diameter=1.6,
           ignore=1,
           NoPartitions=30):
    '''
    Complete lbFCS analysis from raw-data to kinetic analysis.
    '''
    _logo()
    try:
        conc=float(input('Please enter concentration in nM\n'))
    except:
        print('Execution aborted')
        return
    
    start_time=time.time()
    ################################################## Localize & Undrift
    print('Loading movie ...')
    #### Load raw movie
    movie, info = picasso.io.load_movie(path)

    #### Localize
    spots,locs=pic_wrap._localize_movie(movie,box,mng)
    
    #### Save _locs and info_locs
    print('Saving _locs ...')
    info_locs=info.copy()+[{'Box Size':box,
                            'Min. Net Gradient': mng,
                            'Generated by':'localize_undrift.py',
                            }]
    picasso.io.save_locs(os.path.splitext(path)[0]+'_locs.hdf5',
                         locs,
                         info_locs,
                         )
    #### Undrift by RCC
    drift,locs_render=postprocess.undrift(locs,
                         info,
                         segments,
                         display=False,
                         segmentation_callback=None,
                         rcc_callback=None,
                         )
    #### Save _locs_render and info_locs_render
    print('Saving _render ...')
    info_locs_render=info_locs.copy()+[{'Segmentation':segments,
                                        'Generated by':'localize_undrift.py',
                                        }]
    picasso.io.save_locs(os.path.splitext(path)[0]+'_locs_render.hdf5',
                         locs_render,
                         info_locs_render,
                         )
    
    ################################################## Define picks
    #### Render _locs_render to image with oversampling
    print('Rendering locs for pick detection ...')
    image=render.render(locs_render,
                        info,
                        oversampling=oversampling,
                        )[1]
    
    #### Detect picks in _locs_render
    print('Pick detection ...')
    picks=pic_wrap._spots_in_image(image,mng_pick,box_pick,fit=True)
    
    #### Save _picks.yaml in converted locs coordinate version
    lbfcs.io._save_picks(pic_wrap._coordinate_convert(picks,(0,0),oversampling),
                         pick_diameter,
                         os.path.splitext(path)[0]+'_locs_render_autopick.yaml'
                         )

    #### Query locs_render for picks
    print('Indexing & sorting ...')
    centers=np.vstack([picks.x,picks.y]).transpose()/oversampling
    picks_idx=pic_wrap._query_locs_for_centers(locs_render,
                                               centers,
                                               pick_radius=pick_diameter*0.5
                                               )
    #### Assign index to locs_render according to locs
    locs_picked=pic_wrap._get_picked(pd.DataFrame(locs_render),
                                     picks_idx,
                                     field='group')
    #### Dropping, type conversion and sorting
    locs_picked=locs_picked.loc[locs_picked.group>=0,:] # Drop all unassigned localizations i.e. group==-1
    locs_picked=locs_picked.astype({'group':np.uint32}) # Convert to right dtype
    locs_picked.sort_values(['group','frame'],inplace=True) # Sort
    
    #### Save _locs_picked and inf0_locs_picked
    print('Saving _picked ...')
    info_picked=info_locs_render.copy()+[{'Pick diameter':pick_diameter,
                                         'Oversampling':oversampling,
                                         'box':box_pick,
                                         'mng':mng_pick,
                                         'Generated by':'autopick.py',
                                         }]
    picasso.io.save_locs(os.path.splitext(path)[0]+'_locs_render_picked.hdf5',
                         locs_picked.to_records(index=False),
                         info_picked,
                         )
    
    ################################################## Extract kinetic information
    #### Apply props
    print('Calculating kinetics ...')
    NoFrames=info[0]['Frames']
    if NoPartitions==1:
        print('... non-parallel')
        locs_props=props.apply_props(locs_picked,conc,NoFrames,ignore)
    elif NoPartitions>1:
        print('... in parallel')
        locs_props=props.apply_props_dask(locs_picked,conc,NoFrames,ignore,NoPartitions)
    
    #### Remove distributions
    locs_props=locs_props.drop(['trace','tau','g','tau_b_dist','tau_d_dist'],axis=1)

    print('Applying kinetic filter ...')
    groups_nofilter=len(locs_props) # Number of groups before filter
    locs_props=props._kin_filter(locs_props,NoFrames)
    groups_filter=len(locs_props) # Number of groups after filter
    
    #### Add nearest neigbour pick and distance
    print('Calculating nearest neighbour ...')
    locs_props=props_call.props_add_nn(locs_props)
    
    #### Save _locs_render_picked_props.hdf5
    print('Saving _props ...')
        
    ###Save locs_props and info_locs_props
    info_props=info_picked.copy()+[{'Generated by':'pickprops_filter.py',
                                    'ignore':ignore,
                                    'kin_filter': True,
                                    '# of picks before filter':groups_nofilter,
                                    '# of picks after filter':groups_filter,
                                    }]
    lbfcs.io.save_locs(os.path.splitext(path)[0]+'_locs_render_picked_props_ig%i.hdf5'%(ignore),
                       locs_props,
                       info_props,
                       mode='picasso_compatible')
    
    print('Total time: %.2f'%(time.time()-start_time))
    
    return movie,info,locs,locs_render,picks,locs_picked,locs_props,conc

#%%
def main():
    
    ### Define arguments
    parser=argparse.ArgumentParser("lbfcs",
                                    description='lbFCS command line interface')
    parser.add_argument('Path',
                        metavar='path',
                        type=str,
                        help='Path to .ome.tif DNA-PAINT raw data')
    
    ### Parse arguments
    args=parser.parse_args()
    path=args.Path #Path to raw data
    
    ### Checks
    if not os.path.isfile(path): #Check if path leads to file
        path=os.path.join(os.getcwd(),path)
        if not os.path.isfile(path):
            print('No valid file found for given path')
            sys.exit()
        
    ### Execute
    _lbfcs(path)
    
#%%
if __name__=='__main__': 
    try:
        main()
    except:
        raise
        sys.exit()
        